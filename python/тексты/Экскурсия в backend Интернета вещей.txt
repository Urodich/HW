Пастух весь день зависает в смартфоне, при этом его стадо коров остаётся под присмотром. Оператор на нефтяном месторождении прогнозирует поломку сложного агрегата и заранее сообщает о проблеме, чтобы вовремя её решить. Казалось бы, что может быть общего у этих несвязанных вещей… Ответ прост. Им облегчает работу IoT. Предлагаю вам небольшую экскурсию, где мы с вами погуляем вдоль вольеров зоопарка устройств, подивимся его разным «живностям» и окунёмся в Industrial Internet of Things – промышленный интернет вещей.

Я — Владимир Плизга, занимаюсь разработкой backend IoT-платформы AggreGate. Область интернета вещей (IoT, Internet of Things) открывает много интересных и необычных кейсов применения. Сегодня я поделюсь некоторыми из них и помогу вам систематизировать знания в этой сфере.


Понятие “IoT-платформа” появилось относительно недавно, причём почти одновременно в разных и независимых кругах, поэтому общепринятого определения нет. Приведу определение, которое сформировалось в нашей компании:

IoT-платформа – это инструмент, который усиливает компании за счет извлечения ценных сведений из связанного мира.

… empowering businesses … by mining valuable insights from the connected world.

Victor Polyakov, CEO Tibbo Systems

Чтобы понять, из чего состоит IoT-платформа, будем по ходу дела заполнять вот такой серый бублик различными свойствами или качествами, которыми она должна обладать как программный продукт, чтобы соответствовать своему названию.


Итак, первый кейс.

1. Fleet Management
Каким его никто не видел.

Это корова Майя. Очень интересная особа — послушная, отзывчивая, умная, всегда возвращается вовремя. В общем, мечта любого пастуха!


У пастуха  таких милашек целое стадо.


В небольшом хозяйстве он знает их всех по именам. На промышленном предприятии все коровы пронумерованы. Независимо от масштаба, ежедневные задачи пастуха одни и те же:

отвести всех на выпас утром;

никого не потерять;

вовремя всех собрать и отвести обратно вечером.

Это частный случай задачи Fleet Management — управление флотом. Так её называют в промышленной разработке. Под флотом подразумевают парк автомашин или кораблей, в нашем случае — стадо коров.

Задача наблюдения за животным всегда решалась колокольчиком. Его вешали на шею корове. Она ходила, звенела. Пастух слышал её и мог позвать обратно в любой момент. Но цифровая трансформация пришла даже в эту консервативную область. Теперь вместо колокольчика на промышленных коровах есть маленькие коробочки.


Если посмотреть на них поближе, видны их технические характеристики.


Это трекеры двигательной активности крупного рогатого скота. Они содержат два почти независимых устройства:

датчик GPS/ГЛОНАСС/;

акселерометр.

С помощью акселерометра, детектируют паттерны движения коровы и на основе этого присылают пастуху различные сигналы. Если средняя активность животного снизилась, возможно, корова заболела. Если активности нет вообще, начался падеж скота. А если акселерометр детектирует прыжок, значит животное готово к оплодотворению. Оказывается, датчик и это умеет определять.

Этот датчик передаёт собранные данные по беспроводному протоколу LoRaWAN (Long Range Wide Area Network).


Это технология и протокол передачи, который, упрощенно говоря, бьют дальше, чем обычный Wi-Fi, но ближе, чем GSM. Они не требуют сим-карты и в чистом виде потреблять их на backend нельзя. Нужен узел, который будет собирать данные и поднимать их на более высокий уровень сетевого протокола. Это концентратор или шлюз, а по-русски, базовая станция.


Они собирают данные с множества устройств. Это небольшие коробочки с предустановленным производителем Linux, собирающим данные по LoRaWAN, а потом транслирующие их в прикладной протокол.

Вариант архитектуры backend на примере AggreGate и ThingWorx
Как это реализовано на backend:

платформа/язык – Java, так как надо запускаться где попало, чтобы обеспечить максимальную переносимость и способность развёртываться в разных окружениях;

подход – pub-sub, чтобы не поллить устройство постоянно, не сажать его батарейку и не занимать сетевой трафик зазря;

прикладной протокол – MQTT (Message Queuing Telemetry Transport), чтобы с полевых устройств забирать данные и передавать их на backend.

MQTT может работать по TCP/IP. Он не накладывает множество ограничений и сложностей как у  других тяжеловесных сетевых протоколов, то есть не нагружает устройство лишней работой.

Для интеграции со стороны программного кода для этого протокола реализовано целое семейство библиотек под общим зонтиком проекта Eclipse Paho. Их здесь больше десятка, подстроенных под разные языки, в том числе под Java.

На этом шаге заполняю первый кусочек бублика.


Полиглотность интеграций — важное свойство любой IoT-платформы. MQTT и LoRaWAN — не единственные, протоколов таких устройств намного больше. Поддерживать их для IoT-платформы жизненно необходимо. Бессмысленно затачиваться под один протокол.

Как выбирают хранилище
Чтобы определиться с хранилищем на примере IoT-платформ, используют следующие аргументы:

однотипные данные поступают часто и много;

чтений значительно меньше — пастуху достаточно отслеживать только траекторию движения коровы в течение последнего времени. Зачастую нужны не все точки, а только приблизительный путь перемещения;

Транзакционность и гарантии ACID не нужны.

Вероятно, подходит колоночное NoSQL-хранилище. Но какое именно?

Когда выбирали хранилище для AggreGate, опирались, в том числе, на статью Netflix о применении Cassandra, чтобы получить более миллиона RPS (записей) в секунду на своей платформе. Вот ссылка на этот материал: Benchmarking Cassandra Scalability on AWS — Over a million writes per second (Netflix)

Хотелось, чтобы платформа оставалась коробочной и NoSQL-хранилище не ставилось отдельно. Чтобы дистрибутив был один — просто воткнул, запустил одну программу, и вуаля! При этом важно было сохранить масштабируемость, чтобы в любой момент вытащить NoSQL-хранилище и полноценно разворачивать — с отказоустойчивостью и всеми ништяками.

Поэтому была выбрана Cassandra, её можно запустить в embedded режиме прямо в приложение на Java, которым  является сама платформа.

Но есть один нюанс. В официальной документации Cassandra не написано, что её можно использовать в embedded режиме. Такого кейса нет вообще, только для интеграционных кейсов. Зато в одной заявке в их Jira есть — слова разработчика и про поддерживаемый режим (потому что они не контролируют эту JVM и не могут отвечать за то, что кто-то там творит):

... it's an unsupported setup. We do not support embedding C* in a container (i.e. a JVM not controlled "by us").

IMO, supporting C* in such an environment will cause other issues.

Тем не менее, вариант вкусный с разных точек зрения. Плюсы развертывания Cassandra в вариантах:

Embedded

Только одна JVM

Нулевой сетевой лаг

Единство настроек

External

Разные JVM

Масштабируемость

Гибкость настроек

Можно спрятать настройки под интерфейс IoT-платформы, не заставляя пользователя этим грузиться, но ценой каких-то других допущений. Поэтому в случае с AggreGate было выбрано такое решение:


Поддерживаются оба режима: embedded и внешнее стороннее развертывание с подключением по сети к целому кластеру.

Мы предоставили выбор, но не сказали как выбирать. Кроме отказоустойчивости и возможности масштабироваться, есть количественные метрики. Например, потребление памяти с embedded Cassandra.


Так распределяется память наиболее крупных объектов из Heap Dump одного Java-приложения. Видно, что в топе присутствуют запчасти от Cassandra, но в сумме они занимают немного. Хотелось бы избавиться от самого крупного куска (выделен желтым), чтобы оптимизировать потребление.

Если заглянуть внутрь него, оказывается, что это JmxMBean сервер, который на 99% состоит из метрик Cassandra. Так она проявляет своё потребление и поведение в embedded режиме.


Такая картина потребления — звоночек к тому, чтобы здесь embedded Cassandra не использовать. Это повод сделать вторую зарубку про гибкое хранение.


Любая IoT-платформа должна предоставлять возможность конечному пользователю выбирать как сам тип хранилища, так и вариант его развертывания. 

Как работает этот кейс в целом:


У нас есть парк коров, которые умеют передавать данные по протоколу LoRaWAN на базовую станцию. Она транслирует это всё в протокол уже прикладного уровня MQTT и передаёт это на платформу, где работает Eclipse Paho поверх Java. Всё это складывается в хранилище и затем передаётся на UI.

UI может быть разным. Это зависит от требований заказчика. Бывают web-версии, десктопные виджеты и прочее. В данном кейсе вообще было запилено мобильное приложение «Умный пастух», и в нем реально пастух залипал.